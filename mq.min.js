class MQElement{constructor(element){this.el=element}text(newText){if(newText==null){return this.el.innerText}else{this.el.innerText=newText}}html(newHTML){if(newHTML==null){return this.el.innerHTML}else{this.el.innerHTML=newHTML}}attr(attributeName,newValue){if(!attributeName){return}if(newValue){this.el.setAttribute(attributeName,newValue)}else if(newValue==''){this.el.removeAttribute(attributeName)}else{return this.el.getAttribute(attributeName)}}style(attributeName,newValue){if(!attributeName){return}if(newValue){this.el.style[attributeName]=newValue}else{return this.el.style[attributeName]}}hasClass(className){return className?this.el.classList.contains(className):false}toggleClass(className){if(className){this.el.classList.toggle(className)}}addClass(className){if(className){this.el.classList.add(className)}}removeClass(className){if(className){this.el.classList.remove(className)}}on(eventName,action){if(eventName&&action){this.el.addEventListener(eventName,action)}}off(eventName,action){if(eventName&&action){this.el.removeEventListener(eventName,action)}}remove(){this.el.parentNode?.removeChild(this.el)}}class mq{static one(selector){const selection=document.querySelector(selector);return selection?new MQElement(selection):null}static all(selector){const selection=document.querySelectorAll(selector);if(!selection||!selection.length){return[]}let elements=[];selection.forEach(element=>elements.push(new MQElement(element)));return elements}static new(tag,parent){if(!tag){return}let parentToUse=parent;if(parent&&parent instanceof MQElement){parentToUse=parent.el}const element=document.createElement(tag);if(parentToUse){parentToUse.appendChild(element)}else{document.body.appendChild(element)}return new MQElement(element)}}